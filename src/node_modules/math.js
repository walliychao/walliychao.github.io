class Affine {
    constructor(x, y, isVec) {
        if (x) {
            this.x = x
        }
        else {
            this.x = 0
        }
        if (y) {
            this.y = y
        }
        else {
            this.y = 0
        }
        if (isVec) {
            this.z = 0
        }
        else {
            this.z = 1
        }
    }
    isVector() {
        if (typeof this.x === 'number' && typeof this.y === 'number' && this.z === 0) {
            return true
        }
        else return false
    }
    isPoint() {
        if (typeof this.x === 'number' && typeof this.y === 'number' && this.z === 1) {
            return true
        }
        else return false
    }
    static vector(P, Q) {
        if (P.isPoint() && Q.isPoint()) {
            return new Affine(Q.x - P.x, Q.y - P.y, true)
        }
        else return
    }
    static transform(points, M) {
        if (!points.length) {
            return new Affine(
                points.x * M[0][0] + points.y * M[0][1] + points.z * M[0][2],
                points.x * M[1][0] + points.y * M[1][1] + points.z * M[1][2],
                points.z === 0 ? true : false 
            )
        }
        else if (M && M.isMutation()) {
            var pointsNew = []
            for (var i = 0, l = points.length; i < l; i++) {
                pointsNew.push(new Affine(
                    points[i].x * M[0][0] + points[i].y * M[0][1] + points[i].z * M[0][2],
                    points[i].x * M[1][0] + points[i].y * M[1][1] + points[i].z * M[1][2],
                    points[i].z === 0 ? true : false 
                ))
            }
            return pointsNew
        }
        return
    }
}

class Mutation {
    constructor(array1, array2, array3) {
        var temp1 = [0, 0, 0]
        var temp2 = [0, 0, 0]
        var temp3 = [0, 0, 0]
        if (array1 && array1.length === 3) {
            temp1[0] = array1[0]
            temp1[1] = array1[1]
            temp1[2] = array1[2]
        }
        if (array2 && array2.length === 3) {
            temp2[0] = array2[0]
            temp2[1] = array2[1]
            temp2[2] = array2[2]
        }
        if (array3 && array3.length === 3) {
            temp3[0] = array3[0]
            temp3[1] = array3[1]
            temp3[2] = array3[2]
        }
        this[0] = temp1
        this[1] = temp2
        this[2] = temp3

    }
    isMutation() {
        if (this[0] && this[0].length === 3
            && this[1] && this[1].length === 3
            && this[2] && this[2].length === 3) {
            return true
        }
        else return false
    }
    // 平移
    static trans(V) {
        if (V && V.isVector()) {
            return new Mutation([1, 0, V.x], [0, 1, V.y], [0, 0, 1])
        }
        return
    }
    // 旋转
    static rot(theta, Q) {
        if (!Q) {
            Q = new Affine(0, 0)
        }
        if (Q && Q.isPoint()) {
            var array1 = [Math.cos(-theta), -Math.sin(-theta), Q.x * (1 - Math.cos(-theta)) + Q.y * Math.sin(-theta)]
            var array2 = [Math.sin(-theta), Math.cos(-theta), Q.y * (1 - Math.cos(-theta)) - Q.x * Math.sin(-theta)]
            var array3 = [0, 0, 1]
            return new Mutation(array1, array2, array3)
        }
        return
    }
    // 放缩
    static scale(s, Q, V) {
        if (!Q) {
            Q = new Affine(0, 0)
        }
        // 均匀放缩
        if (Q && Q.isPoint() && !V) {
            var array1 = [s, 0, Q.x * (1 - s)]
            var array2 = [0, s, Q.y * (1 - s)]
            var array3 = [0, 0, 1]
            return new Mutation(array1, array2, array3)
        }
        // 非均匀放缩
        if (Q && Q.isPoint() && V && V.isVector()) {
            var M1 = new Mutation([V.x, -V.y, Q.x], [V.y, V.x, Q.y], [0, 0, 1])
            var M2 = new Mutation([s * V.x, -V.y, Q.x], [s * V.y, V.x, Q.y], [0, 0, 1])
            return Mutation.compose(Mutation.invert(M1), M2)
        }
        return
    }
    static image(P1, P2, P3, Q1, Q2, Q3) {
        if (P1 && P1.isPoint() && P2 && P2.isPoint() && P3 && P3.isPoint()
            && Q1 && Q1.isPoint() && Q2 && Q2.isPoint() && Q3 && Q3.isPoint()) {
            var M1 = new Mutation([P1.x, P2.x, P3.x], [P1.y, P2.y, P3.y], [1, 1, 1])
            var M2 = new Mutation([Q1.x, Q2.x, Q3.x], [Q1.y, Q2.y, Q3.y], [1, 1, 1])
            return Mutation.compose(Mutation.invert(M1), M2)
        }
        return
    }
    static invert(M) {
        if (!M.isMutation()) {
             M = new Mutation()
        }
        else if (M[2][0] === 0 && M[2][1] === 0 && M[2][2] === 1) {
            var temp = M[0][0] * M[1][1] - M[1][0] * M[0][1]

            var array1 = [M[1][1] / temp, -M[0][1] / temp,
                (M[0][1] * M[1][2] - M[1][1] * M[0][2]) / temp]

            var array2 = [-M[1][0] / temp, M[0][0] / temp,
                (M[1][0] * M[0][2] - M[0][0] * M[1][2]) / temp]

            var array3 = [0, 0, 1]
            return new Mutation(array1, array2, array3)
        }
        else if (M[2][0] === 1 && M[2][1] === 1 && M[2][2] === 1) {
            var temp = M[0][0] * (M[1][1] - M[1][2])
             + M[0][1] * (M[1][2] - M[1][0])
             + M[0][2] * (M[1][0] - M[1][1])

            var array1 = [(M[1][1] - M[1][2]) / temp, (M[0][2] - M[0][1]) / temp,
                (M[0][1] * M[1][2] - M[1][1] * M[0][2]) / temp]

            var array2 = [(M[1][2] - M[1][0]) / temp, (M[0][0] - M[0][2]) / temp,
                (M[1][0] * M[0][2] - M[0][0] * M[1][2]) / temp]

            var array3 = [(M[1][0] - M[1][1]) / temp, (M[0][1] - M[0][0]) / temp,
                (M[0][0] * M[1][1] - M[1][0] * M[0][1]) / temp]
            return new Mutation(array1, array2, array3)
        }
    }
    static compose(M1, M2) {
        if (!M2) {
            M2 = new Mutation(M1[0], M1[1], M1[2])
            M1 = new Mutation()
        }
        if (M1 && M1.isMutation() && M2 && M2.isMutation()) {
            var array1 = [
                M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2],
                M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2],
                M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2]
            ]
            var array2 = [
                M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2],
                M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2],
                M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2]
            ]
            var array3 = [
                M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2],
                M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2],
                M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2]
            ]
            return new Mutation(array1, array2, array3)
        }
        return
    }
    static multi(s, M) {
        if (!M) {
            M = new Mutation()
        }
        if (M && M.isMutation()) {
            var array1 = [s * M[0][0], s * M[0][1], s * M[0][2]]
            var array2 = [s * M[1][0], s * M[1][1], s * M[1][2]]
            var array3 = [s * M[2][0], s * M[2][1], s * M[2][2]]
            return new Mutation(array1, array2, array3)
        }
        return
    }
    static add(M1, M2) {
        if (!M2) {
            M2 = new Mutation(M1[0], M1[1], M2[2])
            M1 = new Mutation()
        }
        if (M1 && M1.isMutation() && M2 && M2.isMutation()) {
            var array1 = [
                M1[0][0] + M2[0][0],
                M1[0][1] + M2[0][1],
                M1[0][2] + M2[0][2]
            ]
            var array2 = [
                M1[1][0] + M2[1][0],
                M1[1][1] + M2[1][1],
                M1[1][2] + M2[1][2]
            ]
            var array3 = [
                M1[2][0] + M2[2][0],
                M1[2][1] + M2[2][1],
                M1[2][2] + M2[2][2]
            ]
            return new Mutation(array1, array2, array3)
        }
        return
    } 
}

class Complex {
    constructor(a, b) {
        this[0] = a
        this[1] = b
    }

    static add(Z1, Z2) {
        if (!Z2) {
            Z2 = Z1
            Z1 = new Complex(0, 0)
        }
        return new Complex(Z1[0] + Z2[0], Z1[1] + Z2[1])
    }
    static multiply(Z1, Z2) {
        if (!Z2) {
            Z2 = Z1
            Z1 = new Complex(1, 0)
        }
        return new Complex(Z1[0] * Z2[0] - Z1[1] * Z2[1], Z1[1] * Z2[0] + Z1[0] * Z2[1])
    }
    module() {
        return Math.sqrt(this[0] * this[0] + this[1] * this[1])
    }


}

export {Affine, Mutation, Complex}