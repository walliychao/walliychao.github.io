class Node {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = !isNaN(id) && isFinite(id) ? id : null;
    }
    eq(p) {
        var dx = this.x - p.x;
        var dy = this.y - p.y;
        return (dx < 0 ? -dx : dx) < 0.0001 && (dy < 0 ? -dy : dy) < 0.0001;
    }

    greaterThan(p) {
        var dx = this.x - p.x;
        var dy = this.y - p.y;
        if (!this.eq(p) && (dx || dy)) return true
        else return false
    }

    toString() {
        return '(x: ' + this.x + ', y: ' + this.y + ')';
    }
}

class Edge {
    /*
    * @param {Node} p0, p1
    */
    constructor(p0, p1) {
        this.nodes = [p0, p1];
    }

    eq(edge) {
        var na = this.nodes,
            nb = edge.nodes;
        var na0 = na[0], na1 = na[1],
            nb0 = nb[0], nb1 = nb[1];
        return (na0.eq(nb0) && na1.eq(nb1)) || (na0.eq(nb1) && na1.eq(nb0));
    }
}

class Triangle {
    /*
    * @param {Node} p0, p1, p2
    */
    constructor(p0, p1, p2) {
        this.nodes = [p0, p1, p2];
        this.edges = [new Edge(p0, p1), new Edge(p1, p2), new Edge(p2, p0)];
        
        this.id = null;
        this.color = null;
        
        // この三角形の外接円を作成する
        
        var circle = this.circle = new Object();
        
        var ax = p1.x - p0.x, ay = p1.y - p0.y,
            bx = p2.x - p0.x, by = p2.y - p0.y,
            t = (p1.x * p1.x - p0.x * p0.x + p1.y * p1.y - p0.y * p0.y),
            u = (p2.x * p2.x - p0.x * p0.x + p2.y * p2.y - p0.y * p0.y);
        
        var s = 1 / (2 * (ax * by - ay * bx));
        
        circle.x = (by * t - ay * u) * s;
        circle.y = (ax * u - bx * t) * s;

        var dx = p0.x - circle.x;
        var dy = p0.y - circle.y;
        circle.radiusSq = dx * dx + dy * dy;
    }
}

class Delaunay {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    
        this._triangles = null;
    
        this.clear();
    }

    clear() {
        var p0 = new Node(0, 0);
        var p1 = new Node(this.width, 0);
        var p2 = new Node(this.width, this.height);
        var p3 = new Node(0, this.height);
                    
        this._triangles = [
            new Triangle(p0, p1, p2),
            new Triangle(p0, p2, p3)
        ];
        
        return this;
    }

    insert(points) {
        var k, klen, i, ilen, j, jlen;
        var triangles, t, temps, edges, edge, polygon;
        var x, y, circle, dx, dy, distSq;
        
        for (k = 0, klen = points.length; k < klen; k++) {
            x = points[k][0];
            y = points[k][1];
            
            triangles = this._triangles;
            temps = [];
            edges = [];

            for (ilen = triangles.length, i = 0; i < ilen; i++) {
                t = triangles[i];

                // 座標が三角形の外接円に含まれるか調べる
                circle  = t.circle;
                dx = circle.x - x;
                dy = circle.y - y;
                distSq = dx * dx + dy * dy;

                if (distSq < circle.radiusSq) {
                    // 含まれる場合三角形の辺を保存
                    edges.push(t.edges[0], t.edges[1], t.edges[2]);
                } else {
                    // 含まれない場合は持ち越し
                    temps.push(t);
                }
            }

            polygon = [];

            // 辺の重複をチェック, 重複する場合は削除する
            edgesLoop: for (ilen = edges.length, i = 0; i < ilen; i++) {
                edge = edges[i];

                // 辺を比較して重複していれば削除
                for (jlen = polygon.length, j = 0; j < jlen; j++) {
                    if (edge.eq(polygon[j])) {
                        polygon.splice(j, 1);
                        continue edgesLoop;
                    }
                }

                polygon.push(edge);
            }

            for (ilen = polygon.length, i = 0; i < ilen; i++) {
                edge = polygon[i];
                temps.push(new Triangle(edge.nodes[0], edge.nodes[1], new Node(x, y)));
            }

            this._triangles = temps;
        }
    
        return this;
    }

    getTriangles() {
        return this._triangles.slice();
    }

}

export default Delaunay