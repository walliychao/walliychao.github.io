import { getRGB } from './utils'

const Filter = {
    grayscaleFilterR: (imageData) => {
        const width  = imageData.width | 0
        const height = imageData.height | 0
        let data = imageData.data

        let x, y
        let i, step
        let r, g, b

        for (y = 0; y < height; y++) {
            step = y * width
            
            for (x = 0; x < width; x++) {
                // *= 4
                i = (x + step) << 2
                r = data[i]
                g = data[i + 1]
                b = data[i + 2]
            
                data[i] = (r * 0.30 + g * 0.59 + b * 0.11) >> 1
            }
        }

        return imageData
    },

    grayscaleClusterFilterR: (imageData, scaleNumber) => {
        const width  = imageData.width | 0
        const height = imageData.height | 0
        let data = imageData.data

        let x, y
        let i, step
        let r, g, b

        for (y = 0; y < height; y++) {
            step = y * width
            
            for (x = 0; x < width; x++) {
                // *= 4
                i = (x + step) << 2
                r = data[i]
                g = data[i + 1]
                b = data[i + 2]
            
                data[i] = ((r * 0.30 + g * 0.59 + b * 0.11) * scaleNumber / 255) | 0
            }
        }

        return imageData
    },

    colorFilter: (imageData, callback) => {
        const width  = imageData.width | 0
        const height = imageData.height | 0
        let data = imageData.data

        let x, y
        let i, step
        let r, g, b

        const defaultCb = (data, i, color) => {
            let rgb = getRGB(color)
            if (rgb && rgb.length === 3) {
                data[i] &= rgb[0]
                data[i+1] &= rgb[1]
                data[i+2] &= rgb[2]
            }
        }

        for (y = 0; y < height; y++) {
            step = y * width
            
            for (x = 0; x < width; x++) {
                // *= 4
                i = (x + step) << 2
                
                callback && typeof callback === 'function' ?
                    callback(data, i) : defaultCb(data, i, callback)
            }
        }

        return imageData
    },

    convolutionFilterR: (imageData, matrix) => {
        matrix  = matrix.slice()
    
        var data = imageData.data
    
        // copy the original data array, red chanel only
        var len = data.length >> 2
        var copy = new Uint8Array(len)
        for (i = 0; i < len; i++) copy[i] = data[i << 2]
    
        var width  = imageData.width | 0
        var height = imageData.height | 0
        var size  = Math.sqrt(matrix.length)
        var range = size * 0.5 | 0

        var x, y
        var r, g, b, v
        var col, row, sx, sy
        var i, istep, jstep, kstep

        for (y = 0; y < height; y++) {
            istep = y * width

            for (x = 0; x < width; x++) {
                r = g = b = 0

                for (row = -range; row <= range; row++) {
                    sy = y + row
                    jstep = sy * width
                    kstep = (row + range) * size
                    
                    if (sy >= 0 && sy < height) {
                        for (col = -range; col <= range; col++) {
                            sx = x + col

                            if (
                                sx >= 0 && sx < width &&
                                (v = matrix[(col + range) + kstep]) // skip 0 in matrix
                            ) {
                                r += copy[sx + jstep] * v
                            }
                        }
                    }
                }

                if (r < 0) r = 0 
                else if (r > 255) r = 255
                
                // floor
                data[(x + istep) << 2] = r & 0xFF
            }
        }
    
        return imageData
    },

    getEdgePoint: (imageData, detectValue) => {
        var width  = imageData.width
        var height = imageData.height
        var data = imageData.data
        
        detectValue = +detectValue

        var points = []
        var x, y, row, col, sx, sy, step, sum, total
    
        for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
                sum = total = 0
                
                for (row = -1; row <= 1; row++) {
                    sy = y + row
                    step = sy * width
                    if (sy >= 0 && sy < height) {
                        for (col = -1; col <= 1; col++) {
                            sx = x + col

                            if (sx >= 0 && sx < width) {
                                sum += data[(sx + step) << 2]
                                total++
                            }
                        }
                    }
                }
                
                if (total) sum /= total
                if (sum > detectValue) points.push(new Array(x, y))
            }
        }
    
        return points
    },

    mosaicFilter: (imageData, size) => {
        var width  = imageData.width
        var height = imageData.height
        var data = imageData.data

        size = +size 

        var i, x, y, row, col, sx, sy, step, sum, total
        for (y = 0; y < height; y += size) {
            for (x = 0; x < width; x += size) {
                sum = [0, 0, 0], total = 0

                for (row = 0; row <= size; row++) {
                    sy = y + row
                    step = sy * width
                    if (sy >= 0 && sy < height) {
                        for (col = 0; col <= size; col++) {
                            sx = x + col

                            if (sx >= 0 && sx < width) {
                                i = (sx + step) << 2
                                sum[0] += data[i]
                                sum[1] += data[i + 1]
                                sum[2] += data[i + 2]
                                total++
                            }
                        }
                    }
                }

                sum[0] /= total
                sum[1] /= total
                sum[2] /= total

                for (row = 0; row <= size; row++) {
                    sy = y + row
                    step = sy * width
                    if (sy >= 0 && sy < height) {
                        for (col = 0; col <= size; col++) {
                            sx = x + col

                            if (sx >= 0 && sx < width) {
                                i = (sx + step) << 2
                                data[i] = sum[0]
                                data[i + 1] = sum[1]
                                data[i + 2] = sum[2]
                            }
                        }
                    }
                }
            }
        }

        return imageData
    },

    paintFilter: (imageData, colorData, scaleNumber, brushSize) => {
        let matrix = []
        let size = 2 * brushSize + 1
        for (let i = 0; i < size; i++) {
            matrix[i] = 1
        }

        let data = imageData.data
    
        // copy the original data array, red chanel only
        let len = data.length >> 2
        let i
        let copy = new Uint8Array(len)
        for (i = 0; i < len; i++) copy[i] = data[i << 2]
    
        const width  = imageData.width | 0
        const height = imageData.height | 0
        const range = brushSize

        let x, y
        let scaleBucket = new Array(scaleNumber), currScale
        let sum = []
        let col, row, sx, sy
        let istep, jstep, kstep

        for (y = 0; y < height; y++) {
            istep = y * width

            for (x = 0; x < width; x++) {

                for (i = 0; i < scaleBucket.length; i++) scaleBucket[i] = 0

                // get the number of scales in every block
                for (row = -range; row <= range; row++) {
                    sy = y + row
                    jstep = sy * width
                    kstep = (row + range) * size
                    
                    if (sy >= 0 && sy < height) {
                        for (col = -range; col <= range; col++) {
                            sx = x + col

                            if (sx >= 0 && sx < width) {
                                scaleBucket[copy[sx + jstep]]++
                            }
                        }
                    }
                }

                currScale = 0
                // get the scale with max number
                for (i = 1; i < scaleBucket.length; i++) {
                    scaleBucket[i] > scaleBucket[currScale] ? currScale = i : null
                }

                sum[0] = sum[1] = sum[2] = 0

                // get the mean color within that selected scale
                for (row = -range; row <= range; row++) {
                    sy = y + row
                    jstep = sy * width
                    
                    if (sy >= 0 && sy < height) {
                        for (col = -range; col <= range; col++) {
                            sx = x + col

                            if (sx >= 0 && sx < width) {
                                if (copy[sx + jstep] === currScale) {
                                    i = (sx + jstep) << 2
                                    sum[0] += colorData[i]
                                    sum[1] += colorData[i + 1]
                                    sum[2] += colorData[i + 2]
                                } 
                            }
                        }
                    }
                }

                sum[0] /= scaleBucket[currScale]
                sum[1] /= scaleBucket[currScale]
                sum[2] /= scaleBucket[currScale]
                
                i = (x + istep) << 2
                data[i] = sum[0]
                data[i + 1] = sum[1]
                data[i + 2] = sum[2]
            }
        }
    
        return imageData
    }
}

export default Filter